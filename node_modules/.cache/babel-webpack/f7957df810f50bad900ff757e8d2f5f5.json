{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/dzubu/source/repos/bloomteq gui/bloomteqGui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\n\nexport class MessageBuffer {\n  constructor(protocol, connection, bufferSize) {\n    this._bufferSize = 100000;\n    this._messages = [];\n    this._totalMessageCount = 0;\n    this._waitForSequenceMessage = false; // Message IDs start at 1 and always increment by 1\n\n    this._nextReceivingSequenceId = 1;\n    this._latestReceivedSequenceId = 0;\n    this._bufferedByteCount = 0;\n    this._reconnectInProgress = false;\n    this._protocol = protocol;\n    this._connection = connection;\n    this._bufferSize = bufferSize;\n  }\n\n  _send(message) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const serializedMessage = _this._protocol.writeMessage(message);\n\n      let backpressurePromise = Promise.resolve(); // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\n\n      if (_this._isInvocationMessage(message)) {\n        _this._totalMessageCount++;\n\n        let backpressurePromiseResolver = () => {};\n\n        let backpressurePromiseRejector = () => {};\n\n        if (isArrayBuffer(serializedMessage)) {\n          _this._bufferedByteCount += serializedMessage.byteLength;\n        } else {\n          _this._bufferedByteCount += serializedMessage.length;\n        }\n\n        if (_this._bufferedByteCount >= _this._bufferSize) {\n          backpressurePromise = new Promise((resolve, reject) => {\n            backpressurePromiseResolver = resolve;\n            backpressurePromiseRejector = reject;\n          });\n        }\n\n        _this._messages.push(new BufferedItem(serializedMessage, _this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\n      }\n\n      try {\n        // If this is set it means we are reconnecting or resending\n        // We don't want to send on a disconnected connection\n        // And we don't want to send if resend is running since that would mean sending\n        // this message twice\n        if (!_this._reconnectInProgress) {\n          yield _this._connection.send(serializedMessage);\n        }\n      } catch {\n        _this._disconnected();\n      }\n\n      yield backpressurePromise;\n    })();\n  }\n\n  _ack(ackMessage) {\n    let newestAckedMessage = -1; // Find index of newest message being acked\n\n    for (let index = 0; index < this._messages.length; index++) {\n      const element = this._messages[index];\n\n      if (element._id <= ackMessage.sequenceId) {\n        newestAckedMessage = index;\n\n        if (isArrayBuffer(element._message)) {\n          this._bufferedByteCount -= element._message.byteLength;\n        } else {\n          this._bufferedByteCount -= element._message.length;\n        } // resolve items that have already been sent and acked\n\n\n        element._resolver();\n      } else if (this._bufferedByteCount < this._bufferSize) {\n        // resolve items that now fall under the buffer limit but haven't been acked\n        element._resolver();\n      } else {\n        break;\n      }\n    }\n\n    if (newestAckedMessage !== -1) {\n      // We're removing everything including the message pointed to, so add 1\n      this._messages = this._messages.slice(newestAckedMessage + 1);\n    }\n  }\n\n  _shouldProcessMessage(message) {\n    if (this._waitForSequenceMessage) {\n      if (message.type !== MessageType.Sequence) {\n        return false;\n      } else {\n        this._waitForSequenceMessage = false;\n        return true;\n      }\n    } // No special processing for acks, pings, etc.\n\n\n    if (!this._isInvocationMessage(message)) {\n      return true;\n    }\n\n    const currentId = this._nextReceivingSequenceId;\n    this._nextReceivingSequenceId++;\n\n    if (currentId <= this._latestReceivedSequenceId) {\n      if (currentId === this._latestReceivedSequenceId) {\n        // Should only hit this if we just reconnected and the server is sending\n        // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\n        this._ackTimer();\n      } // Ignore, this is a duplicate message\n\n\n      return false;\n    }\n\n    this._latestReceivedSequenceId = currentId; // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\n    // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\n\n    this._ackTimer();\n\n    return true;\n  }\n\n  _resetSequence(message) {\n    if (message.sequenceId > this._nextReceivingSequenceId) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n\n      return;\n    }\n\n    this._nextReceivingSequenceId = message.sequenceId;\n  }\n\n  _disconnected() {\n    this._reconnectInProgress = true;\n    this._waitForSequenceMessage = true;\n  }\n\n  _resend() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const sequenceId = _this2._messages.length !== 0 ? _this2._messages[0]._id : _this2._totalMessageCount + 1;\n      yield _this2._connection.send(_this2._protocol.writeMessage({\n        type: MessageType.Sequence,\n        sequenceId\n      })); // Get a local variable to the _messages, just in case messages are acked while resending\n      // Which would slice the _messages array (which creates a new copy)\n\n      const messages = _this2._messages;\n\n      for (const element of messages) {\n        yield _this2._connection.send(element._message);\n      }\n\n      _this2._reconnectInProgress = false;\n    })();\n  }\n\n  _dispose(error) {\n    error !== null && error !== void 0 ? error : error = new Error(\"Unable to reconnect to server.\"); // Unblock backpressure if any\n\n    for (const element of this._messages) {\n      element._rejector(error);\n    }\n  }\n\n  _isInvocationMessage(message) {\n    // There is no way to check if something implements an interface.\n    // So we individually check the messages in a switch statement.\n    // To make sure we don't miss any message types we rely on the compiler\n    // seeing the function returns a value and it will do the\n    // exhaustive check for us on the switch statement, since we don't use 'case default'\n    switch (message.type) {\n      case MessageType.Invocation:\n      case MessageType.StreamItem:\n      case MessageType.Completion:\n      case MessageType.StreamInvocation:\n      case MessageType.CancelInvocation:\n        return true;\n\n      case MessageType.Close:\n      case MessageType.Sequence:\n      case MessageType.Ping:\n      case MessageType.Ack:\n        return false;\n    }\n  }\n\n  _ackTimer() {\n    var _this3 = this;\n\n    if (this._ackTimerHandle === undefined) {\n      this._ackTimerHandle = setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          if (!_this3._reconnectInProgress) {\n            yield _this3._connection.send(_this3._protocol.writeMessage({\n              type: MessageType.Ack,\n              sequenceId: _this3._latestReceivedSequenceId\n            }));\n          } // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\n\n        } catch {}\n\n        clearTimeout(_this3._ackTimerHandle);\n        _this3._ackTimerHandle = undefined; // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\n      }), 1000);\n    }\n  }\n\n}\n\nclass BufferedItem {\n  constructor(message, id, resolver, rejector) {\n    this._message = message;\n    this._id = id;\n    this._resolver = resolver;\n    this._rejector = rejector;\n  }\n\n} //# sourceMappingURL=MessageBuffer.js.map","map":{"version":3,"sources":["C:/Users/dzubu/source/repos/bloomteq gui/bloomteqGui/node_modules/@microsoft/signalr/dist/esm/MessageBuffer.js"],"names":["MessageType","isArrayBuffer","MessageBuffer","constructor","protocol","connection","bufferSize","_bufferSize","_messages","_totalMessageCount","_waitForSequenceMessage","_nextReceivingSequenceId","_latestReceivedSequenceId","_bufferedByteCount","_reconnectInProgress","_protocol","_connection","_send","message","serializedMessage","writeMessage","backpressurePromise","Promise","resolve","_isInvocationMessage","backpressurePromiseResolver","backpressurePromiseRejector","byteLength","length","reject","push","BufferedItem","send","_disconnected","_ack","ackMessage","newestAckedMessage","index","element","_id","sequenceId","_message","_resolver","slice","_shouldProcessMessage","type","Sequence","currentId","_ackTimer","_resetSequence","stop","Error","_resend","messages","_dispose","error","_rejector","Invocation","StreamItem","Completion","StreamInvocation","CancelInvocation","Close","Ping","Ack","_ackTimerHandle","undefined","setTimeout","clearTimeout","id","resolver","rejector"],"mappings":"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","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { isArrayBuffer } from \"./Utils\";\r\n/** @private */\r\nexport class MessageBuffer {\r\n    constructor(protocol, connection, bufferSize) {\r\n        this._bufferSize = 100000;\r\n        this._messages = [];\r\n        this._totalMessageCount = 0;\r\n        this._waitForSequenceMessage = false;\r\n        // Message IDs start at 1 and always increment by 1\r\n        this._nextReceivingSequenceId = 1;\r\n        this._latestReceivedSequenceId = 0;\r\n        this._bufferedByteCount = 0;\r\n        this._reconnectInProgress = false;\r\n        this._protocol = protocol;\r\n        this._connection = connection;\r\n        this._bufferSize = bufferSize;\r\n    }\r\n    async _send(message) {\r\n        const serializedMessage = this._protocol.writeMessage(message);\r\n        let backpressurePromise = Promise.resolve();\r\n        // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\r\n        if (this._isInvocationMessage(message)) {\r\n            this._totalMessageCount++;\r\n            let backpressurePromiseResolver = () => { };\r\n            let backpressurePromiseRejector = () => { };\r\n            if (isArrayBuffer(serializedMessage)) {\r\n                this._bufferedByteCount += serializedMessage.byteLength;\r\n            }\r\n            else {\r\n                this._bufferedByteCount += serializedMessage.length;\r\n            }\r\n            if (this._bufferedByteCount >= this._bufferSize) {\r\n                backpressurePromise = new Promise((resolve, reject) => {\r\n                    backpressurePromiseResolver = resolve;\r\n                    backpressurePromiseRejector = reject;\r\n                });\r\n            }\r\n            this._messages.push(new BufferedItem(serializedMessage, this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\r\n        }\r\n        try {\r\n            // If this is set it means we are reconnecting or resending\r\n            // We don't want to send on a disconnected connection\r\n            // And we don't want to send if resend is running since that would mean sending\r\n            // this message twice\r\n            if (!this._reconnectInProgress) {\r\n                await this._connection.send(serializedMessage);\r\n            }\r\n        }\r\n        catch {\r\n            this._disconnected();\r\n        }\r\n        await backpressurePromise;\r\n    }\r\n    _ack(ackMessage) {\r\n        let newestAckedMessage = -1;\r\n        // Find index of newest message being acked\r\n        for (let index = 0; index < this._messages.length; index++) {\r\n            const element = this._messages[index];\r\n            if (element._id <= ackMessage.sequenceId) {\r\n                newestAckedMessage = index;\r\n                if (isArrayBuffer(element._message)) {\r\n                    this._bufferedByteCount -= element._message.byteLength;\r\n                }\r\n                else {\r\n                    this._bufferedByteCount -= element._message.length;\r\n                }\r\n                // resolve items that have already been sent and acked\r\n                element._resolver();\r\n            }\r\n            else if (this._bufferedByteCount < this._bufferSize) {\r\n                // resolve items that now fall under the buffer limit but haven't been acked\r\n                element._resolver();\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (newestAckedMessage !== -1) {\r\n            // We're removing everything including the message pointed to, so add 1\r\n            this._messages = this._messages.slice(newestAckedMessage + 1);\r\n        }\r\n    }\r\n    _shouldProcessMessage(message) {\r\n        if (this._waitForSequenceMessage) {\r\n            if (message.type !== MessageType.Sequence) {\r\n                return false;\r\n            }\r\n            else {\r\n                this._waitForSequenceMessage = false;\r\n                return true;\r\n            }\r\n        }\r\n        // No special processing for acks, pings, etc.\r\n        if (!this._isInvocationMessage(message)) {\r\n            return true;\r\n        }\r\n        const currentId = this._nextReceivingSequenceId;\r\n        this._nextReceivingSequenceId++;\r\n        if (currentId <= this._latestReceivedSequenceId) {\r\n            if (currentId === this._latestReceivedSequenceId) {\r\n                // Should only hit this if we just reconnected and the server is sending\r\n                // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\r\n                this._ackTimer();\r\n            }\r\n            // Ignore, this is a duplicate message\r\n            return false;\r\n        }\r\n        this._latestReceivedSequenceId = currentId;\r\n        // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\r\n        // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\r\n        this._ackTimer();\r\n        return true;\r\n    }\r\n    _resetSequence(message) {\r\n        if (message.sequenceId > this._nextReceivingSequenceId) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\r\n            return;\r\n        }\r\n        this._nextReceivingSequenceId = message.sequenceId;\r\n    }\r\n    _disconnected() {\r\n        this._reconnectInProgress = true;\r\n        this._waitForSequenceMessage = true;\r\n    }\r\n    async _resend() {\r\n        const sequenceId = this._messages.length !== 0\r\n            ? this._messages[0]._id\r\n            : this._totalMessageCount + 1;\r\n        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Sequence, sequenceId }));\r\n        // Get a local variable to the _messages, just in case messages are acked while resending\r\n        // Which would slice the _messages array (which creates a new copy)\r\n        const messages = this._messages;\r\n        for (const element of messages) {\r\n            await this._connection.send(element._message);\r\n        }\r\n        this._reconnectInProgress = false;\r\n    }\r\n    _dispose(error) {\r\n        error !== null && error !== void 0 ? error : (error = new Error(\"Unable to reconnect to server.\"));\r\n        // Unblock backpressure if any\r\n        for (const element of this._messages) {\r\n            element._rejector(error);\r\n        }\r\n    }\r\n    _isInvocationMessage(message) {\r\n        // There is no way to check if something implements an interface.\r\n        // So we individually check the messages in a switch statement.\r\n        // To make sure we don't miss any message types we rely on the compiler\r\n        // seeing the function returns a value and it will do the\r\n        // exhaustive check for us on the switch statement, since we don't use 'case default'\r\n        switch (message.type) {\r\n            case MessageType.Invocation:\r\n            case MessageType.StreamItem:\r\n            case MessageType.Completion:\r\n            case MessageType.StreamInvocation:\r\n            case MessageType.CancelInvocation:\r\n                return true;\r\n            case MessageType.Close:\r\n            case MessageType.Sequence:\r\n            case MessageType.Ping:\r\n            case MessageType.Ack:\r\n                return false;\r\n        }\r\n    }\r\n    _ackTimer() {\r\n        if (this._ackTimerHandle === undefined) {\r\n            this._ackTimerHandle = setTimeout(async () => {\r\n                try {\r\n                    if (!this._reconnectInProgress) {\r\n                        await this._connection.send(this._protocol.writeMessage({ type: MessageType.Ack, sequenceId: this._latestReceivedSequenceId }));\r\n                    }\r\n                    // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\r\n                }\r\n                catch { }\r\n                clearTimeout(this._ackTimerHandle);\r\n                this._ackTimerHandle = undefined;\r\n                // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\r\n            }, 1000);\r\n        }\r\n    }\r\n}\r\nclass BufferedItem {\r\n    constructor(message, id, resolver, rejector) {\r\n        this._message = message;\r\n        this._id = id;\r\n        this._resolver = resolver;\r\n        this._rejector = rejector;\r\n    }\r\n}\r\n//# sourceMappingURL=MessageBuffer.js.map"]},"metadata":{},"sourceType":"module"}